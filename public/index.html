<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Timetable AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <style>
    :root { --glass: rgba(15,23,42,.75); }
    body{
      background: radial-gradient(1200px 600px at 20% -10%, #1d2a5b33, transparent 70%),
                  radial-gradient(1000px 500px at 100% 0%, #0ea5e933, transparent 60%),
                  linear-gradient(135deg, #0b1020 0%, #0f172a 50%, #0b1222 100%);
      color:#e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    .card{ background:var(--glass); border:1px solid rgba(148,163,184,.25); backdrop-filter: blur(8px);
           box-shadow:0 20px 60px rgba(0,0,0,.35); }
    .ring-sky{ box-shadow: 0 0 0 2px rgba(56,189,248,.6) inset; }
    .skeleton{ background: linear-gradient(90deg,#0b1222,#0f172a 50%,#0b1222); background-size: 200% 100%;
               animation: sk 1.2s linear infinite; } @keyframes sk { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
    .markdown-body{ word-break:break-word; }
    .markdown-body h1,.markdown-body h2,.markdown-body h3{font-weight:600;margin-top:1rem}
    .markdown-body p,.markdown-body li{margin:0.3rem 0}
    .markdown-body table{
      border-collapse:collapse;
      width:100%;
      margin:0.5rem 0;
      font-size:0.95rem;
      display:block;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .markdown-body th,.markdown-body td{
      border:1px solid #334155;
      padding:4px 6px;
      text-align:left;
      word-break:break-word;
      white-space:normal;
    }
    .markdown-body code{background:#0f172a;border-radius:4px;padding:2px 4px;font-family:monospace}
    /* Modal */
    .modal-mask{ position:fixed; inset:0; background:rgba(2,6,23,.55); backdrop-filter: blur(4px); display:none; }
    .modal-mask.show{ display:block; }
    .modal{ width:min(720px,96vw); max-height:90vh; overflow:auto; background:rgba(17,24,39,.96);
            border:1px solid #334155; border-radius:16px; margin:6vh auto; padding:16px; }
    .modal.show{ display:block; }
    .mic-btn{
      position:relative;
      transition:background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
    }
    .mic-btn svg{
      width:18px;
      height:18px;
      color:#e2e8f0;
      transition:color .2s ease;
    }
    .mic-btn:hover{ background-color:rgba(51,65,85,.9); }
    .mic-btn.recording{
      background:rgba(248,113,113,.18);
      border-color:rgba(248,113,113,.6);
      box-shadow:0 0 0 2px rgba(248,113,113,.25);
    }
    .mic-btn.recording svg{ color:#fca5a5; }
    #groupSuggestions{ z-index:80; }
    #answer{ overflow-x:auto; }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center py-6 px-3 sm:py-10 sm:px-4">

  <main class="w-full max-w-3xl space-y-5">
    <!-- Top bar (no emojis) -->
    <header class="flex items-center justify-between px-1">
      <h1 class="text-xl sm:text-2xl font-semibold tracking-tight">Timetable AI</h1>
      <div class="flex items-center gap-2">
        <button id="manageNamesBtn"
                class="px-3 py-1.5 text-sm rounded-lg bg-slate-800/80 border border-slate-700 hover:bg-slate-700">
          Directory
        </button>
        <span class="hidden sm:inline text-sm text-slate-400">Ready</span>
      </div>
    </header>

    <!-- Composer -->
    <section class="card rounded-2xl p-3 sm:p-4">
      <label for="q" class="block text-xs sm:text-sm text-slate-400 mb-2">Ask a question</label>
      <div class="relative">
        <input id="q" autocomplete="off"
               placeholder="e.g. When are Kuang Wenâ€™s free periods tomorrow?"
               class="w-full rounded-2xl bg-slate-950/60 border border-slate-700/60 pl-4 pr-24 py-3 text-base
                      focus:outline-none focus:ring-2 focus:ring-sky-400/70 placeholder:text-slate-500" />
        <!-- Mic button -->
        <button id="micBtn" type="button"
                class="mic-btn absolute right-2 top-1/2 -translate-y-1/2 flex items-center justify-center
                       h-10 w-10 rounded-xl bg-slate-800/70 border border-slate-700/60 text-slate-200
                       hover:bg-slate-700 transition-all"
                aria-label="Record with microphone" title="Record with microphone">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 15a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3z"></path>
            <path d="M19 11a7 7 0 0 1-14 0"></path>
            <line x1="12" y1="19" x2="12" y2="23"></line>
            <line x1="8" y1="23" x2="16" y2="23"></line>
          </svg>
        </button>
        <!-- Group suggestions -->
        <div id="groupSuggestions"
             class="hidden absolute left-0 right-16 top-full mt-2">
          <div class="rounded-2xl bg-slate-950/95 border border-slate-800 shadow-xl overflow-hidden">
            <div class="px-3 py-2 border-b border-slate-800 text-xs text-slate-400">
              Insert a saved group
            </div>
            <div id="groupSuggestionsList" class="max-h-60 overflow-auto divide-y divide-slate-900/70 text-sm"></div>
          </div>
        </div>
      </div>
      <p class="mt-2 text-xs text-slate-500">Tip: type "[" or "@" to insert a saved group from your Directory.</p>
      <div class="mt-3 flex items-center gap-2">
        <button id="askBtn" class="inline-flex items-center gap-2 px-4 py-2.5 rounded-xl
                                   bg-indigo-600 hover:bg-indigo-500 transition-all font-semibold">
          Ask
        </button>
        <p id="status" class="text-sm text-slate-400"></p>
      </div>
    </section>

    <!-- Answer -->
    <section class="card rounded-2xl p-4 sm:p-5">
      <h2 class="text-lg font-semibold mb-2">Answer</h2>
      <div id="answer" class="markdown-body min-h-[90px] text-base leading-7 text-slate-100">
        <span class="text-slate-400">Ask something to get started.</span>
      </div>
    </section>

    <!-- Raw JSON dropdown -->
    <details class="card rounded-2xl p-3 sm:p-4 select-text" id="rawDetails">
      <summary class="cursor-pointer list-none flex items-center justify-between">
        <span class="font-semibold">Raw JSON (collapsed)</span>
        <span id="rawMeta" class="text-xs text-slate-400"></span>
      </summary>
      <div class="mt-3">
        <div class="flex items-center gap-2 mb-2">
          <button id="copyBtn" class="px-3 py-1.5 rounded-lg text-sm bg-slate-800 border border-slate-700 hover:bg-slate-700">Copy JSON</button>
          <span id="copyTip" class="text-xs text-slate-400"></span>
        </div>
        <pre id="raw" class="max-h-80 overflow-auto rounded-xl p-3 bg-slate-950/70 border border-slate-800 text-[13px]"></pre>
      </div>
    </details>
  </main>

  <!-- Directory Modal -->
  <div id="namesModal" class="modal-mask">
    <div class="modal rounded-2xl">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-lg font-semibold">Directory</h3>
        <button id="closeNames"
                class="px-3 py-1.5 text-sm rounded-lg bg-slate-800/80 border border-slate-700 hover:bg-slate-700">
          Close
        </button>
      </div>

      <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
        <!-- Lists column -->
        <div class="sm:col-span-1">
          <label class="block text-sm text-slate-400 mb-1">Groups</label>
          <p class="text-xs text-slate-500 mb-2">Pick a group to edit or insert into questions.</p>
          <select id="listsSelect" size="8"
                  class="w-full rounded-lg bg-slate-950/60 border border-slate-700/60 p-2 text-sm"></select>
          <div id="listPreview"
               class="mt-2 rounded-lg bg-slate-950/60 border border-slate-700/60 p-2 text-xs text-slate-400 min-h-[80px]">
            <p class="text-slate-500">No group selected.</p>
          </div>
          <div class="flex gap-2 mt-2">
            <button id="newList" class="px-3 py-1.5 rounded-lg text-sm bg-slate-800 border border-slate-700 hover:bg-slate-700">New</button>
            <button id="loadList" class="px-3 py-1.5 rounded-lg text-sm bg-slate-800 border border-slate-700 hover:bg-slate-700">Load</button>
            <button id="deleteList" class="px-3 py-1.5 rounded-lg text-sm bg-slate-800 border border-slate-700 hover:bg-slate-700">Delete</button>
          </div>
        </div>

        <!-- Editor column -->
        <div class="sm:col-span-2">
          <label class="block text-sm text-slate-400 mb-1">Group name</label>
          <input id="listNameInput" class="w-full rounded-lg bg-slate-950/60 border border-slate-700/60 p-2 mb-2" placeholder="e.g. council teachers" />
          <label class="block text-sm text-slate-400 mb-1">People (one per line)</label>
          <textarea id="namesEditor" rows="10"
                    class="w-full rounded-lg bg-slate-950/60 border border-slate-700/60 p-3 text-sm"
                    placeholder="Kuang Wen&#10;Gabriel&#10;Adrian"></textarea>
          <div class="flex gap-2 mt-2">
            <button id="saveList" class="px-3 py-1.5 rounded-lg text-sm bg-indigo-600 hover:bg-indigo-500">Save</button>
            <button id="clearEditor" class="px-3 py-1.5 rounded-lg text-sm bg-slate-800 border border-slate-700 hover:bg-slate-700">Clear</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const qEl = document.getElementById('q');
    const askBtn = document.getElementById('askBtn');
    const micBtn = document.getElementById('micBtn');
    const statusEl = document.getElementById('status');
    const ansEl = document.getElementById('answer');
    const rawEl = document.getElementById('raw');
    const rawMeta = document.getElementById('rawMeta');
    const copyBtn = document.getElementById('copyBtn');
    const copyTip = document.getElementById('copyTip');
    const rawDetails = document.getElementById('rawDetails');
    const groupSuggestions = document.getElementById('groupSuggestions');
    const groupSuggestionsList = document.getElementById('groupSuggestionsList');
    const listPreview = document.getElementById('listPreview');

    // Modal elements
    const manageNamesBtn = document.getElementById('manageNamesBtn');
    const namesModal = document.getElementById('namesModal');
    const closeNames = document.getElementById('closeNames');
    const listsSelect = document.getElementById('listsSelect');
    const listNameInput = document.getElementById('listNameInput');
    const namesEditor = document.getElementById('namesEditor');
    const newListBtn = document.getElementById('newList');
    const loadListBtn = document.getElementById('loadList');
    const deleteListBtn = document.getElementById('deleteList');
    const saveListBtn = document.getElementById('saveList');
    const clearEditorBtn = document.getElementById('clearEditor');

    let recording = false, mediaStream = null, mediaRecorder = null;
    let audioContext = null, analyser = null, analyserData = null, silenceInterval = null;

    function clearOutput() {
      ansEl.innerHTML = '<div class="h-6 rounded skeleton"></div><div class="h-6 rounded skeleton mt-2 w-3/4"></div>';
      rawEl.textContent = '';
      rawMeta.textContent = '';
      rawDetails.open = false;
    }

    async function ask() {
      const rawQuestion = qEl.value.trim();
      if (!rawQuestion) return;
      hideGroupSuggestions();
      const question = replaceGroupPlaceholders(rawQuestion);
      clearOutput();
      setStatus('Sendingâ€¦');
      askBtn.disabled = true;
      micBtn.disabled = true;

      try {
        const apiRes = await fetch('/proxy', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ question, mode: 'auto' }) });
        const data = await apiRes.json();

        rawEl.textContent = JSON.stringify(data, null, 2);
        const count = Array.isArray(data?.results) ? data.results.length : 0;
        rawMeta.textContent = `items: ${count}`;

        setStatus('Summarizingâ€¦');
        const results = Array.isArray(data?.results) ? data.results : [];
        const sumPayload = {
          question,
          results,
          queryType: data?.queryType || '',
          timetable: data?.timetable || null,
          title: data?.title || '',
          notes: data?.notes || '',
          teachers: Array.isArray(data?.teachers) ? data.teachers : [],
          clarify: data?.clarify || null
        };
        const sumRes = await fetch('/summarize', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(sumPayload) });
        const j = await sumRes.json();
        const summary = j?.choices?.[0]?.message?.content || j?.openai_raw?.choices?.[0]?.message?.content || 'No summary produced.';
        ansEl.innerHTML = DOMPurify.sanitize(marked.parse(summary || ''));
        setStatus('Done');
      } catch (err) {
        ansEl.innerHTML = '<span class="text-red-400">Something went wrong.</span>';
        setStatus('Error');
        console.error(err);
      } finally {
        askBtn.disabled = false;
        micBtn.disabled = false;
      }
    }

    function setStatus(t){ statusEl.textContent = t || ''; }
    qEl.addEventListener('keydown', (e) => {
      if (handleSuggestionKeyDown(e)) return;
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        ask();
      }
    });
    qEl.addEventListener('input', updateSuggestionState);
    qEl.addEventListener('blur', () => setTimeout(hideGroupSuggestions, 120));
    askBtn.addEventListener('click', ask);

    copyBtn?.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(rawEl.textContent || ''); copyTip.textContent = 'Copied!'; setTimeout(() => copyTip.textContent = '', 1200); } catch {}
    });

    // --- Mic (fills input, improved error reporting) ---
    micBtn.addEventListener('click', async () => {
      try {
        if (!navigator.mediaDevices || !window.MediaRecorder) return alert('Microphone recording not supported.');
        if (!recording) {
          clearOutput();
          setStatus('Recordingâ€¦ tap again to stop');
          micBtn.classList.add('ring-sky', 'recording');
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
          const chunks = [];
          mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
          mediaRecorder.onstop = async () => {
            recording = false;
            micBtn.classList.remove('ring-sky', 'recording');
            setStatus('Transcribingâ€¦');
            clearSilenceMonitor();
            const blob = new Blob(chunks, { type: 'audio/webm' });
            const form = new FormData();
            form.append('audio', blob, 'question.webm');
            try {
              const r = await fetch('/whisper', { method: 'POST', body: form });
              const j = await r.json();
              if (j?.ok === false) {
                console.warn('Whisper response:', j);
                alert(j.error || 'Transcription failed.');
              } else if (j?.text) {
                qEl.value = j.text.trim();
                qEl.focus();
                qEl.setSelectionRange(qEl.value.length, qEl.value.length);
              } else {
                console.warn('Whisper response (no text):', j);
                alert('No text returned from transcription.');
              }
              setStatus('Ready');
            } catch (e) {
              console.error(e); setStatus('Transcription error');
            } finally {
              if (mediaStream) {
                mediaStream.getTracks().forEach(t => t.stop());
                mediaStream = null;
              }
            }
            mediaRecorder = null;
          };
          mediaRecorder.start();
          recording = true;
          startSilenceMonitor();
        } else {
          stopRecording('manual');
        }
      } catch (e) {
        console.error(e);
        recording = false;
        micBtn.classList.remove('ring-sky', 'recording');
        setStatus('Mic unavailable');
        clearSilenceMonitor();
      }
    });

    function startSilenceMonitor(){
      clearSilenceMonitor();
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx || !mediaStream) return;
        audioContext = new AudioCtx();
        const source = audioContext.createMediaStreamSource(mediaStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyserData = new Float32Array(analyser.fftSize);
        source.connect(analyser);
        let silenceMs = 0;
        const interval = 250;
        silenceInterval = setInterval(() => {
          try {
            analyser.getFloatTimeDomainData(analyserData);
            let sum = 0;
            for (let i = 0; i < analyserData.length; i++) {
              const v = analyserData[i];
              sum += v * v;
            }
            const rms = Math.sqrt(sum / analyserData.length);
            if (rms < 0.01) {
              silenceMs += interval;
              if (silenceMs >= 10000) {
                stopRecording('silence');
              }
            } else {
              silenceMs = 0;
            }
          } catch (err) {
            console.warn('Silence monitor error', err);
            clearSilenceMonitor();
          }
        }, interval);
      } catch (err) {
        console.warn('Silence detection unavailable:', err);
        clearSilenceMonitor();
      }
    }

    function clearSilenceMonitor(){
      if (silenceInterval) {
        clearInterval(silenceInterval);
        silenceInterval = null;
      }
      if (audioContext) {
        try { audioContext.close(); } catch {}
        audioContext = null;
      }
      analyser = null;
      analyserData = null;
    }

    function stopRecording(reason){
      if (!recording || !mediaRecorder) return;
      recording = false;
      if (reason === 'silence') {
        setStatus('Stopping (silence)â€¦');
      } else {
        setStatus('Stoppingâ€¦');
      }
      clearSilenceMonitor();
      try {
        mediaRecorder.stop();
      } catch (err) {
        console.error('Failed to stop recorder', err);
      }
    }

    // ===== Directory (Create / Load / Save / Delete) =====
    const LS_KEY = 'ttai:names:lists';
    const MAX_SUGGESTIONS = 8;

    function getLists(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch { return {}; } }
    function setLists(obj){ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }
    function parsePeople(text){
      return (text || '')
        .split(/\r?\n/)
        .map(line => line.trim())
        .filter(Boolean);
    }
    function formatCount(count){
      if (!count) return 'empty';
      return count === 1 ? '1 name' : `${count} names`;
    }

    function loadGroupIntoEditor(name){
      if (!name){
        listNameInput.value = '';
        namesEditor.value = '';
        return;
      }
      const lists = getLists();
      listNameInput.value = name;
      namesEditor.value = lists[name] || '';
    }

    function updateListPreview(name){
      if (!listPreview) return;
      listPreview.innerHTML = '';
      if (!name){
        const empty = document.createElement('p');
        empty.className = 'text-slate-500';
        empty.textContent = 'No group selected.';
        listPreview.appendChild(empty);
        return;
      }
      const lists = getLists();
      if (!(name in lists)){
        const missing = document.createElement('p');
        missing.className = 'text-slate-500';
        missing.textContent = 'Group not found.';
        listPreview.appendChild(missing);
        return;
      }
      const people = parsePeople(lists[name]);
      if (!people.length){
        const none = document.createElement('p');
        none.className = 'text-slate-500';
        none.textContent = 'This group has no names yet.';
        listPreview.appendChild(none);
        return;
      }
      const meta = document.createElement('p');
      meta.className = 'text-[11px] uppercase tracking-wide text-slate-500 mb-1';
      meta.textContent = `${people.length} ${people.length === 1 ? 'person' : 'people'}`;
      listPreview.appendChild(meta);
      const ul = document.createElement('ul');
      ul.className = 'space-y-1 text-slate-200';
      people.forEach(person => {
        const li = document.createElement('li');
        li.textContent = person;
        ul.appendChild(li);
      });
      listPreview.appendChild(ul);
    }

    function refreshListsUI(selected=''){
      const lists = getLists();
      const names = Object.keys(lists).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
      listsSelect.innerHTML = '';
      let resolved = selected && names.includes(selected) ? selected : names[0] || '';
      names.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        const count = parsePeople(lists[name]).length;
        opt.textContent = `${name} â€¢ ${formatCount(count)}`;
        if (name === resolved) opt.selected = true;
        listsSelect.appendChild(opt);
      });
      if (!resolved) listsSelect.selectedIndex = -1;
      updateListPreview(resolved);
      loadGroupIntoEditor(resolved);
      return resolved;
    }

    function replaceGroupPlaceholders(text){
      if (!text) return text;
      const lists = getLists();
      const groupNames = Object.keys(lists);
      if (!groupNames.length) return text;
      let working = text;
      if (working.includes('@')) {
        const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        groupNames.forEach(name => {
          const pattern = new RegExp(`(^|[\\s(])@\\s*${escapeRegExp(name)}(?=$|[\\s,.!?;:)])`, 'gi');
          working = working.replace(pattern, (_, prefix) => `${prefix}[${name}]`);
        });
      }
      if (!working.includes('[')) return working;
      const index = {};
      groupNames.forEach(name => { index[name.toLowerCase()] = parsePeople(lists[name]); });
      return working.replace(/\[([^[\]]+)\]/g, (full, raw) => {
        const key = raw.trim().toLowerCase();
        const names = index[key];
        if (!key || !names || !names.length) return full;
        return names.join(', ');
      });
    }

    function openDirectoryModal(){
      const current = refreshListsUI(listsSelect.value || '');
      if (current) listsSelect.value = current;
      namesModal.classList.add('show');
    }

    manageNamesBtn.addEventListener('click', openDirectoryModal);
    closeNames.addEventListener('click', () => namesModal.classList.remove('show'));
    namesModal.addEventListener('click', (e) => { if (e.target === namesModal) namesModal.classList.remove('show'); });

    listsSelect.addEventListener('change', () => {
      const sel = listsSelect.value;
      loadGroupIntoEditor(sel);
      updateListPreview(sel);
    });

    newListBtn.addEventListener('click', () => {
      listsSelect.selectedIndex = -1;
      loadGroupIntoEditor('');
      updateListPreview('');
      listNameInput.focus();
    });

    clearEditorBtn.addEventListener('click', () => {
      namesEditor.value = '';
      namesEditor.focus();
    });

    loadListBtn.addEventListener('click', () => {
      const sel = listsSelect.value;
      if (!sel) return;
      loadGroupIntoEditor(sel);
      namesEditor.focus();
    });

    deleteListBtn.addEventListener('click', () => {
      const sel = listsSelect.value;
      if (!sel) return;
      const lists = getLists();
      if (!lists[sel]) return;
      if (!confirm(`Delete group "${sel}"?`)) return;
      delete lists[sel];
      setLists(lists);
      const next = refreshListsUI('');
      if (next) listsSelect.value = next;
    });

    saveListBtn.addEventListener('click', () => {
      const name = (listNameInput.value || '').trim();
      if (!name) return alert('Please enter a group name.');
      const people = parsePeople(namesEditor.value);
      const lists = getLists();
      lists[name] = people.join('\n');
      setLists(lists);
      const resolved = refreshListsUI(name);
      if (resolved) listsSelect.value = resolved;
      alert('Saved.');
    });

    // ===== Group suggestions while typing =====
    let triggerStart = null;
    let triggerChar = null;
    let suggestionItems = [];
    let suggestionIndex = -1;

    function suggestionsOpen(){
      return suggestionItems.length > 0 && !groupSuggestions.classList.contains('hidden');
    }

    function hideGroupSuggestions(){
      triggerStart = null;
      triggerChar = null;
      suggestionItems = [];
      suggestionIndex = -1;
      groupSuggestions.classList.add('hidden');
      groupSuggestionsList.innerHTML = '';
    }

    function highlightSuggestion(idx){
      suggestionIndex = idx;
      const buttons = groupSuggestionsList.querySelectorAll('button[data-index]');
      buttons.forEach(btn => {
        const bIdx = Number(btn.dataset.index);
        if (bIdx === idx) {
          btn.classList.add('bg-slate-800/70');
        } else {
          btn.classList.remove('bg-slate-800/70');
        }
      });
      if (idx >= 0) {
        const target = groupSuggestionsList.querySelector(`button[data-index="${idx}"]`);
        if (target) target.scrollIntoView({ block: 'nearest' });
      }
    }

    function renderGroupSuggestions(items, lists){
      const limited = items.slice(0, MAX_SUGGESTIONS);
      if (!limited.length) {
        hideGroupSuggestions();
        return;
      }
      groupSuggestionsList.innerHTML = '';
      limited.forEach((name, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.dataset.index = String(idx);
        btn.dataset.name = name;
        btn.className = 'w-full flex items-center justify-between px-3 py-2 text-left text-slate-200 hover:bg-slate-800/70 focus:outline-none';
        const label = document.createElement('span');
        label.textContent = name;
        const badge = document.createElement('span');
        badge.className = 'text-xs text-slate-400';
        badge.textContent = formatCount(parsePeople(lists[name]).length);
        btn.appendChild(label);
        btn.appendChild(badge);
        groupSuggestionsList.appendChild(btn);
      });
      groupSuggestions.classList.remove('hidden');
      suggestionItems = limited;
      const autoIndex = limited.length === 1 ? 0 : -1;
      highlightSuggestion(autoIndex);
    }

    function updateSuggestionState(){
      if (document.activeElement !== qEl) {
        hideGroupSuggestions();
        return;
      }
      const caret = qEl.selectionStart;
      if (caret == null) {
        hideGroupSuggestions();
        return;
      }
      const value = qEl.value;
      const lastBracket = value.lastIndexOf('[', caret - 1);
      const lastAt = value.lastIndexOf('@', caret - 1);
      const start = Math.max(lastBracket, lastAt);
      if (start === -1) {
        hideGroupSuggestions();
        return;
      }
      const char = value[start];
      if (char !== '[' && char !== '@') {
        hideGroupSuggestions();
        return;
      }
      if (char === '[') {
        const closeIdx = value.indexOf(']', start + 1);
        if (closeIdx !== -1 && closeIdx < caret) {
          hideGroupSuggestions();
          return;
        }
      }
      const fragment = value.slice(start + 1, caret);
      if (fragment.includes('\n')) {
        hideGroupSuggestions();
        return;
      }
      if (char === '[' && fragment.includes('[')) {
        hideGroupSuggestions();
        return;
      }
      if (char === '@') {
        const beforeChar = start > 0 ? value[start - 1] : '';
        if (beforeChar && !/[\s([{]/.test(beforeChar)) {
          hideGroupSuggestions();
          return;
        }
        if (fragment.includes('@') || fragment.includes('[')) {
          hideGroupSuggestions();
          return;
        }
      }
      const lists = getLists();
      const groupNames = Object.keys(lists);
      if (!groupNames.length) {
        hideGroupSuggestions();
        return;
      }
      const query = fragment.trim().toLowerCase();
      const matches = groupNames
        .slice()
        .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
        .filter(name => !query || name.toLowerCase().includes(query));
      if (!matches.length) {
        hideGroupSuggestions();
        return;
      }
      triggerStart = start;
      triggerChar = char;
      renderGroupSuggestions(matches, lists);
    }

    function insertGroupPlaceholder(name){
      if (triggerStart == null || triggerStart < 0) return;
      const value = qEl.value;
      const caret = qEl.selectionStart ?? value.length;
      let end = caret;
      if (triggerChar === '[') {
        const closeIdx = value.indexOf(']', triggerStart);
        if (closeIdx !== -1 && closeIdx >= caret) {
          end = closeIdx + 1;
        }
      } else if (triggerChar === '@') {
        const trailing = value.slice(caret).match(/^[^\s@[\]{}(),.;!?]*/);
        if (trailing) end = caret + trailing[0].length;
      }
      const before = value.slice(0, triggerStart);
      const after = value.slice(end);
      const inserted = `[${name}]`;
      qEl.value = `${before}${inserted}${after}`;
      const newCaret = before.length + inserted.length;
      qEl.setSelectionRange(newCaret, newCaret);
      hideGroupSuggestions();
      qEl.focus();
      updateSuggestionState();
    }

    function handleSuggestionKeyDown(e){
      if (!suggestionsOpen()) return false;
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        if (!suggestionItems.length) return true;
        const lastIndex = suggestionItems.length - 1;
        const nextIndex = e.key === 'ArrowDown'
          ? (suggestionIndex + 1 > lastIndex ? 0 : suggestionIndex + 1)
          : (suggestionIndex <= 0 ? lastIndex : suggestionIndex - 1);
        highlightSuggestion(nextIndex);
        return true;
      }
      if (e.key === 'Enter') {
        const idx = suggestionIndex >= 0 ? suggestionIndex : (suggestionItems.length === 1 ? 0 : -1);
        if (idx === -1) return false;
        e.preventDefault();
        insertGroupPlaceholder(suggestionItems[idx]);
        return true;
      }
      if (e.key === 'Tab') {
        if (!suggestionItems.length) return false;
        e.preventDefault();
        const idx = suggestionIndex >= 0 ? suggestionIndex : 0;
        insertGroupPlaceholder(suggestionItems[idx]);
        return true;
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        hideGroupSuggestions();
        return true;
      }
      return false;
    }

    groupSuggestionsList.addEventListener('mousedown', (e) => {
      const btn = e.target.closest('button[data-name]');
      if (!btn) return;
      e.preventDefault();
      insertGroupPlaceholder(btn.dataset.name);
    });

    groupSuggestionsList.addEventListener('mouseover', (e) => {
      const btn = e.target.closest('button[data-index]');
      if (!btn) return;
      const idx = Number(btn.dataset.index);
      if (!Number.isNaN(idx) && idx !== suggestionIndex) highlightSuggestion(idx);
    });

    // Prime directory inputs on load
    refreshListsUI(listsSelect.value || '');
  </script>
</body>
</html>
